NB.Enface.Paragraphs = {
/*
		get_target_element_from_p:function(q){
		  return $J('.target p','#p_'+q);
    },
    focus_current:function(){
      var element = $J('#p_'+NB.p.current+' .target p').focus();    
      element.active();    
    },
		first: function(e){
  			NB.Enface.slider.object.setValue(1);
        _gaq.push(['_trackEvent','Navigator', 'Slider', 'First']);
  			Event.stop(e);
		},
		previous: function(e){
			if (NB.p.current>1) {
  			NB.Enface.slider.object.setValue(NB.p.current - 1);
        _gaq.push(['_trackEvent','Navigator', 'Slider', 'Previous']);
      }
  			Event.stop(e);
		},
		next: function (e) {
      if (NB.p.current<NB.p.count) {
  			NB.Enface.slider.object.setValue(NB.p.current + 1);
        _gaq.push(['_trackEvent','Navigator', 'Slider', 'Next']);
			}
  			Event.stop(e);
		},
		last: function (e) {
  			NB.Enface.slider.object.setValue(NB.p.count);
        _gaq.push(['_trackEvent','Navigator', 'Slider', 'Last']);
  			Event.stop(e);
		},
		goto: function(which,e){
        NB.Enface.slider.object.setValue(which);
  			Event.stop(e);
		},
*/
    /*    colorize:function(q){
       // cache calculated words in an array
       // if we do spellcheck, etc it would need to go here
       if($('tool_colorize').hasClassName('on')){
  			 q.update(NB.String.strip(q.innerHTML).replace(/\w+/g,function(match){
  			  var score = NB.App.word_score(match[0]);
//  			  NB.Nav.Track('Text: '+q.innerHTML);
//  			  NB.Nav.Track('Score: '+score);
          if (score<0) {
            return '<span class="neg neg'+score+'" title="&#x25bc;'+(score*-1)+'">'+match[0]+'</span>';
          } else if (score>0) {
            return '<span class="pos pos'+score+'" title="&#x25b2;'+score+'">'+match[0]+'</span>';
          } else {
            return '<span title="&#x25b6;0">'+match[0]+'</span>';
          }
         }));
       }
    },

    word_score:function(word){
//    NB.Nav.Track(NB.Anagram.anagram);
      return word.toLowerCase().split('').collect(function(letter) {
        return NB.Anagram.anagram[NB.alphanumArray.indexOf(letter)];
      }).inject(0,function(acc,n) { return acc + n*-1/Math.abs(n*-1); });
    },
    check_text:function(element){
      var elementContent = element.innerHTML;
      var elementContentStripped = NB.String.strip(elementContent.replace(/<del>.*?<\/del>/g,''));
      var targetLength = elementContentStripped.replace(/[^0-9a-zA-Z]/g,'').length;
      var difference = element.attr('sourcelength') - targetLength;
//      NB.Nav.Track(elementContentStripped.replace(/[^0-9a-zA-Z]/g,''));
//      var changes = NB.String.diff.measure(element.attr('p_text'),elementContent);
      var alertMessage = '';
      var error_status = 0;
      if (/([a-zA-Z])\1\1+/.test(element.innerHTML)){
        alertMessage = '<span class="neg">Contains gibberish.</span>';
        error_status = 2;
        element.update(elementContent.replace(/([a-zA-Z])\1\1+/g,'<span class="gibberish">$&</span>'));
      } else if (difference > NB.Enface.lengthTolerance) {
        alertMessage = '<span class="neg">Too short (-'+difference+' letters).</span>';
        error_status = 3;
      } else if (targetLength>NB.Enface.lengthThreshold&&(difference < NB.Enface.lengthTolerance*-1)) {
        alertMessage = '<span class="neg">Too long (+'+(difference*-1)+' letters).</span>';
        error_status = 4;
//      } else if (NB.Anagram.score>0&&$('alert').innerHTML=='') {
//        alertMessage = '<span>Click anywhere outside the paragraph to save it.</span>';
      //Levenshtein is slow on long texts - left to last
      //Arbitrarily testing only first 500 characters
      //We can do some sort of bubble-check
      //Choose next 500, etc
      //If we knew the caret position, we could just test around it
      } else {
        var changes = NB.String.levenshtein(element.attr('p_text'),elementContent.truncate(500,''));
        var changesTolerance = parseInt(targetLength*(NB.Enface.changesTolerancePercentage/100));
        changesTolerance = NB.Number.range(changesTolerance,NB.Enface.changesToleranceMin,NB.Enface.changesToleranceMax);
        if (changes > changesTolerance) {
            alertMessage = '<span class="neg">Too many changes ('+changes+'/'+changesTolerance+').</span>';
            error_status = 1;
        }
      }
      element.attr('error_status',error_status);
      element.attr('alert',alertMessage);
      return alertMessage;      
    },
/*
    uncolorize:function(q){
			   q.update(NB.String.strip(q.innerHTML));
    },
		add_editors: function(){
	      $J('.target p').each( function(item) {
					 NB.Enface.editor.addInstance(item);
				});
    },
		remove_editors: function(){
	      $J('.target p').each( function(item) {
//					 NB.Enface.editor.removeInstance(item);
				});
    }
*/
};
